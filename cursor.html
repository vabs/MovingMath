<html>
<head>
  <style>
          #canvas{
                  width:        100%;
                  height:       100%;
          }
          
  </style>
        
</head>
<body>

  <canvas id="canvas"></canvas>
 
  <script src="http://js.leapmotion.com/0.2.0/leap.min.js"></script>
  <script src="./collection.js"></script>
  <script src="./collection_actions.js"></script>

  <script>
    // Collection = require("./collection.js");
        // Get the canvas DOM element 
    var canvas = document.getElementById('canvas');

    // Making sure we have the proper aspect ratio for our canvas
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    // Create the context we will use for drawing
    var context = canvas.getContext('2d');

    // Save the canvas width and canvas height
    // as easily accesible variables
    var width = canvas.width;
    var height = canvas.height;

    var controller = new Leap.Controller({
      enableGestures: true,
      // frameEventName: 'animationFrame'
    });

    var pointable_id;

    var normalFromLeap = function(pos, iBox) {
      var npos = iBox.normalizePoint(pos, true);
      return [npos[0], 1 - npos[1], npos[2]];
    }
    var canvasFromNormal = function(pos) {
      return [pos[0] * width, pos[1] * height, pos[2]];
    }
    var canvasFromLeap = function(pos, iBox) {
      return canvasFromNormal(normalFromLeap(pos, iBox));
    }
    var flatten = function(pos) {
      return [pos[0], pos[1]];
    }

    var distance = function(pos1, pos2)
    {
        return Leap.vec3.distance([pos1[0], pos1[1], 0], [pos2[0], pos2[1], 0]);
    }

    var draw = function() {
      drawCollections(context);

      // Write the math
      context.fillStyle = "#000000";
      context.font = "100px Arial";
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.fillText(math, width / 2, height / 9);
    }

    var findPrimaryFinger = function(frame) {
      var numberOfPointables = frame.pointables.length;
      var interactionBox = frame.interactionBox;

      if (numberOfPointables == 0)
        return;

      // Find the past primary pointer or get a new one
      var pointable = frame.pointable(pointable_id);
      if (!pointable.valid)
        pointable = frame.pointables[0];
      pointable_id = pointable.id;
    }

    var drawFingers = function(frame) {
      var numberOfPointables = frame.pointables.length;
      var interactionBox = frame.interactionBox;

      context.fillStyle = "#000000"
      context.strokeStyle = "#000000"
      // Draw each finger with a circle
      for (var i = 0; i < numberOfPointables; i++) {
        var p = frame.pointables[i];
        if (p.timeVisible < 0.5) continue;
        var canvasPosition = canvasFromLeap(p.tipPosition, interactionBox);

        var canvasX = canvasPosition[0];
        var canvasY = canvasPosition[1];

        var radiusScale = p.touchDistance;
        if (radiusScale < 0)
          radiusScale = 0;
        var radius = 25 * (radiusScale + 0.5);

        context.beginPath();
        if (p.id == pointable_id) { // Primary finger gets bigger circle
          context.arc(canvasX, canvasY, radius, 0, 2 * Math.PI);
          if (p.touchDistance > 0)
            context.stroke();
          else
            context.fill();
        } else {
          context.arc(canvasX, canvasY, 5, 0, 2 * Math.PI);
          context.stroke();
        }
      }
    }

    var processGestures = function(frame) {
      var interactionBox = frame.interactionBox;
      var numberOfGestures = frame.gestures.length;
      function isFromMain(g) {
        for (var j = 0; j < g.pointableIds.length; j++) {
          if (g.pointableIds[j] == pointable_id)
            return true;
        }
        return false;
      }

      for (var i = 0; i < numberOfGestures; i++) {
        var g = frame.gestures[i];
        if (! isFromMain(g))
          continue;
        // TODO Would like to click at center of box to create
        if (g.type == "screenTap") {
          var canvasPosition = canvasFromLeap(g.position, interactionBox);
          makeCollectionAt(canvasPosition);
        }
        else if (g.type == "circle" && g.state == "stop" && g.duration < 2000) {
          var canvasPosition = canvasFromLeap(g.center, interactionBox);
          rotateCollectionAt(canvasPosition);
        }
      }
    }

    var smearing = false;
    var doActions = function(frame) {
      var p = frame.pointable(pointable_id);
      if (!p.valid)
        return;

      var iBox = frame.interactionBox;
      var position = canvasFromLeap(p.tipPosition, iBox);

      //  To start an action, must be
      //  - not currently moving something
      //  - not smearing in the last frame
      //  - at touching distance
      if (p && p.valid && !moving() && !smearing && p.touchDistance <= 0) {
        var numFingers = 0;
        for (var i = 0; i < frame.pointables.length; i++) {
          var q = frame.pointables[i];
          if (p.id == q.id) continue;
          if (q.timeVisible < 0.5) continue;
          var d = distance(p.tipPosition, q.tipPosition);
          if (d > 20 && d < 50)
            numFingers++;
        }
        if (numFingers == 0)
          startDrag(position);
        else
          startMultiply(position);
      }
      else if (p && p.valid && moving() && p.touchDistance <= 0)
        updateDrag(position);
      else if (p && p.valid && moving() && p.touchDistance > 0)
        stopDrag(position);

      //  Cursor is at touching depth but not doing anything
      smearing = p.touchDistance <= 0 && !moving();
    }

    math = "";
    var writeMath = function(string) {
      math = string;
    }

    controller.on( 'frame' , function(frame){
      // Cursor.leapToCursor(frame);

      // Clears the canvas so frames don't build on each other.
      context.clearRect(0, 0, width, height);

      if (!frame.valid)
        return;

      findPrimaryFinger(frame);
      processGestures(frame);
      doActions(frame);
      draw();
      drawFingers(frame);
    });
    controller.connect();

  </script>

</body>
</html>
