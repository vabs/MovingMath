<html>
<head>
  <style>
          #canvas{
                  width:        100%;
                  height:       100%;
          }
          
  </style>
        
</head>
<body>

  <canvas id="canvas"></canvas>
 
  <script src="https://js.leapmotion.com/0.4.3/leap.min.js"></script>
  <script src="./collection.js"></script>
  <script src="./collection_actions.js"></script>

  <script>
    // Collection = require("./collection.js");
        // Get the canvas DOM element 
    var canvas = document.getElementById('canvas');

    // Making sure we have the proper aspect ratio for our canvas
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    // Create the context we will use for drawing
    var context = canvas.getContext('2d');

    // Save the canvas width and canvas height
    // as easily accesible variables
    var width = canvas.width;
    var height = canvas.height;

    var controller = new Leap.Controller({
      enableGestures: true,
      // frameEventName: 'animationFrame'
    });

    var pointable_id;

    var normalFromLeap = function(pos, iBox) {
      var npos = iBox.normalizePoint(pos, true);
      return [npos[0], 1 - npos[1], npos[2]];
    }
    var canvasFromNormal = function(pos) {
      return [pos[0] * width, pos[1] * height, pos[2]];
    }
    var canvasFromLeap = function(pos, iBox) {
      return canvasFromNormal(normalFromLeap(pos, iBox));
    }
    var flatten = function(pos) {
      return [pos[0], pos[1]];
    }

    var draw = function() {
      drawCollections(context);
    }

    var findPrimaryFinger = function(frame) {
      var numberOfPointables = frame.pointables.length;
      var interactionBox = frame.interactionBox;

      if (numberOfPointables == 0)
        return;

      // Find the past primary pointer or get a new one
      var pointable = frame.pointable(pointable_id);
      if (!pointable.valid)
        pointable = frame.pointables[0];
      pointable_id = pointable.id;
    }

    var drawFingers = function(frame) {
      var numberOfPointables = frame.pointables.length;
      var interactionBox = frame.interactionBox;

      context.fillStyle = "#000000"
      context.strokeStyle = "#000000"
      // Draw each finger with a circle
      for (var i = 0; i < numberOfPointables; i++) {
        var p = frame.pointables[i];
        var canvasPosition = canvasFromLeap(p.tipPosition, interactionBox);

        var canvasX = canvasPosition[0];
        var canvasY = canvasPosition[1];

        var radiusScale = p.touchDistance;
        if (radiusScale < 0)
          radiusScale = 0;
        var radius = 25 * (radiusScale + 0.5);

        context.beginPath();
        if (p.id == pointable_id) { // Primary finger gets bigger circle
          context.arc(canvasX, canvasY, radius, 0, 2 * Math.PI);
          if (p.touchDistance > 0)
            context.stroke();
          else
            context.fill();
        } else {
          context.arc(canvasX, canvasY, 5, 0, 2 * Math.PI);
          context.stroke();
        }
      }
    }

    var processGestures = function(frame) {
      var interactionBox = frame.interactionBox;
      var numberOfGestures = frame.gestures.length;
      for (var i = 0; i < numberOfGestures; i++) {
        var g = frame.gestures[i];
        if (g.type == "screenTap") {
          for (var j = 0; j < g.pointableIds.length; j++) {
            if (g.pointableIds[j] == pointable_id) {
              //boxes.push(interactionBox.normalizePoint(g.position));
              // TODO Would like to click at center of box to create
              var canvasPosition = canvasFromLeap(g.position, interactionBox);
              makeCollectionAt(canvasPosition);
            }
          }
        }
      }
    }

    var doActions = function(frame) {
      var p = frame.pointable(pointable_id);
      if (!p.valid)
        return;

      var iBox = frame.interactionBox;
      var position = canvasFromLeap(p.tipPosition, iBox);
      var isMoving = moving();

      if (p && p.valid && !isMoving && p.touchDistance <= 0) {
        var numFingers = 0;
        for (var i = 0; i < frame.pointables.length; i++) {
          var q = frame.pointables[i];
          if (p.id == q.id) continue;
          var pposition = flatten(position);
          var qposition = flatten(canvasFromLeap(q.tipPosition, iBox));
          var distance = 0; //vec2.distance(pposition, qposition);
          if (distance > 100 && distance < 150)
            numFingers++;
        }
        startDrag(position, numFingers);
      }
      else if (p && p.valid && moving() && p.touchDistance <= 0)
        updateDrag(position);
      else if (p && p.valid && moving() && p.touchDistance > 0)
        stopDrag(position);
    }

    var writeMath = function(string) {
      context.font = "100px Arial";
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.fillText(string, width / 2, height / 10);
    }

    controller.on( 'frame' , function(frame){
      // Cursor.leapToCursor(frame);

      // Clears the canvas so frames don't build on each other.
      context.clearRect(0, 0, width, height);

      if (!frame.valid)
        return;

      findPrimaryFinger(frame);
      processGestures(frame);
      doActions(frame);
      draw();
      drawFingers(frame);
    });
    controller.connect();

  </script>

</body>
</html>
